#+TITLE: 设计模式
#+DATE:

* link
  [[http://www.cnblogs.com/jiese/tag/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/][url]]

* 23种模式
** Command命令模式:
   作用： 将一个请求封装为一个对象，从而使你可用不同的请求对客户进行参数化；
   对请求排队或记录请求日志，以及支持可撤销的操作。
   由于“行为请求者”与“行为实现者”的紧耦合，使用命令模式，可以对请求排
   队或记录请求日志，以及支持可撤销的操作。
   - 说明：
     优点：
     1, 它能较容易地设计一个命令队列；
     2，在需要的情况下，可以较容易地将命令记入日志；
     3，允许接收请求的一方决定是否要否决请求。
     4，可以容易地实现对请求的撤销和重做；
     5，由于加进新的具体命令类不影响其他的类，因此增加新的具体命令类很容易。

** Mediator中介者模式
  作用：用一个中介对象来封装一系列的对象交互。中介者使各对象不需要显式
  地相互引用，从而使其耦合松散，而且可以独立地改变它们之间的交互。
  - 说明：
    1. Mediator 模式中，每个Colleague 维护一个 Mediator，当要进行通信时，每个具体的 Colleague 直接向ConcreteMediator 发信息，至于信息发到哪里，则由 ConcreteMediator 来决定。
    2. ConcreteColleagueA 和 ConcreteColleagueB 不必维护对各自的引用，甚至它们也不知道各个的存在。
    3. 优点是，各个 Colleague 减少了耦合。
    4. 缺点是，由于 Mediator 控制了集中化，于是就把 Colleague 之间的交互复杂性变为了中介者的复杂性，也就是中介者会变的比任何一个 Colleague 都复杂。
       
** Memento备忘录模式
   作用：在不破坏封装性的前提下，捕获一个对象的内部状态，并在该对象之
   外保存这个状态，这样以后就可将该对象恢复到原先保存的状态。
   如果在某个系统中使用命令模式时，需要实现命令的撤销功能，那么命令模式可以使用备忘录模式来存储可撤销操作的状态。
** Observer观察者模式
   作用：观察者模式定义了一种一对多的依赖关系，让多个观察者对象
   同时监听某一个主题对象，这个主题对象在状态发生变化时，会通知
   所有观察者对象，使它们能够自动更新自己
   特点：将一个系统分割成一系列相互协作的类有一个很不好的副作用，那就是需要维护相关对象间的一致性。我们不希望为了维持一致性而使各类紧密耦合，这样会给维护、扩展和重用都带来不便。
   何时使用：当一个对象的改变需要同时改变其他对象的时候，而且它不知道具体有多少对象有待改变时，应该考虑使用观察者模式。观察者模式所做的工作其实就是在解除耦合。让耦合的双方都依赖于抽象，而不是依赖于具体。从而使得各自的变化都不会影响另一边的变化。
** Strategy策略模式
   作用：定义了算法家族，分别封装起来，让他们之间可以互相替换，此模式
   让算法的变化，不会影响到使用算法的客户。
** TemplateMethod模板方法模式
   作用：定义一个操作中的算法的骨架。而将一些步骤延迟到子类中，模板方法使得子类可以不改变一个算法的结构即可重定义该算法的某些特定步骤。
   特点：模板方法模式是通过把不变行为搬移到基类，去除之类中的重复代码来体现它的优势。当不变的和可变的行为在方法的子类实现中混合在一起的时候，不变的行为就会在子类中重复出现。通过模板方法模式把这些行为搬移到单一的地方，这样就帮助子类摆脱重复的不变行为的纠缠。
** Proxy代理模式
   作用：为其他对象提供一种代理以控制对这个对象的访问。
   代理的种类：
   如果按照使用目的来划分，代理有以下几种：
   远程（Remote）代理：为一个位于不同的地址空间的对象提供一个局域代表对象。这个不同的地址空间可以是在本机器中，也可是在另一台机器中。远程代理又叫做大使（Ambassador）。 也就是为一个对象在不同的地址空间提供局部代表。这样可以隐藏一个对象存在于不同地址空间的事实。
   虚拟（Virtual）代理：根据需要创建一个资源消耗较大的对象，使得此对象只在需要时才会被真正创建。是根据需要创建开销很大的对象。通过它来存放实例化需要很长时间的真实对象。  
   Copy-on-Write代理：虚拟代理的一种。把复制（克隆）拖延到只有在客户端需要时，才真正采取行动。
   保护（Protect or Access）代理：控制对一个对象的访问，如果需要，可以给不同的用户提供不同级别的使用权限。 用来控制真实对象访问时的权限。一般用于对象应该有不同的访问权限的时候。
   Cache代理：为某一个目标操作的结果提供临时的存储空间，以便多个客户端可以共享这些结果。 防火墙（Firewall）代理：保护目标，不让恶意用户接近。 同步化（Synchronization）代理：使几个用户能够同时使用一个对象而没有冲突。
   智能引用（Smart Reference）代理：当一个对象被引用时，提供一些额外的操作，比如将对此对象调用的次数记录下来等。 是指当调用真实的对象时，代理处理另外一些事。如计算真实对象的引用次数，这样当该对象没有引用时，可以自动释放它；或当第一次引用一个持久对象时，将它装入内存；或在访问一个实际对象前，检查是否已经锁定它，以确保其他对象不能改变它。它们都是通过代理在访问一个对象时附加一些内务处理。
   在所有种类的代理模式中，虚拟（Virtual）代理、远程（Remote）代理、智能引用代理（Smart Reference Proxy）和保护（Protect or Access）代理是最为常见的代理模式。
** Flyweight享元模式
   作用：运用共享技术有效地支持大量细粒度的对象。
   内部状态intrinsic和外部状态extrinsic：
   1）Flyweight模式中，最重要的是将对象分解成intrinsic和extrinsic两部分。
   2）内部状态：在享元对象内部并且不会随环境改变而改变的共享部分，可以称为是享元对象的内部状态
   3）外部状态：而随环境改变而改变的，取决于应用环境，或是实时数据，这些不可以共享的东西就是外部状态了。
   4）内部状态和外部状态之间的区别：在Flyweight模式应用中，通常修改的是外部状态属性，而内部状态属性一般都是用于参考或计算时引用。Flyweight执行时所需的状态必定是内部的或外部的。内部状态存储于ConcreteFlyweight对象之中；而外部状态则由Client对象存储或计算。当用户调用Flyweight对象的操作时，将该状态传递给它。
** Composite组合模式
   作用：将对象组合成树形结构以表示“部分-整体”的层次结构。Composite使得用户对单个对象和组合对象的使用具有一致性。
** Decorator装饰模式
   作用：动态地给一个对象添加一些额外的职责，就增加功能来说，装饰模式比生成子类更为灵活。
** Adapter适配器模式
   作用：将一个类的接口转换成客户希望的另外一个接口。Adapter模式使得原
   本由于接口不兼容而不能一起工作的那些类可以一起工作。
   分为类适配器模式和对象适配器模式。
** Bridge桥接模式
   作用：将抽象部份与它的实现部份分离，使它们都可以独立地变化。
   将抽象(Abstraction)与实现(Implementation)分离，使得二者可以独立地变化。
   桥接模式号称设计模式中最难理解的模式之一，关键就是这个抽象和实现的分离非常让人奇怪，大部分人刚看到这个定义的时候都会认为实现就是继承自抽象，那怎么可能将他们分离呢。
** Prototype原型模式
   作用：用原型实例指定创建对象的种类，并且通过拷贝这些原型创建新的对象。
   Prototype模式提供了一个通过已存在对象进行新对象创建的接口（Clone）， Clone()实现和具体的语言相关，在C++中通过拷贝构造函数实现。
** Builder建造者模式
   作用:将一个复杂对象的构建与它的表示分离，使得同样的构建过程可以创建不同的表示。
   Builder模式和AbstractFactory模式在功能上很相似，因为都是用来创建大的复杂的对象，它们的区别是：Builder模式强调的是一步步创建对象，并通过相同的创建过程可以获得不同的结果对象，一般来说Builder模式中对象不是直接返回的。而在AbstractFactory模式中对象是直接返回的，AbstractFactory模式强调的是为创建多个相互依赖的对象提供一个同一的接口。
   适用于以下情况:
   1)当创建复杂对象的算法应该独立于该对象的组成部分以及它们的装配方式时。
   2)当构造过程必须允许被构造的对象有不同的表示时。
** Singleton单例模式
   Singleton 是对全局变量的取代策略
   作用：保证一个类只能有一个实例，并提供一个全局唯一的访问点。
   仅有一个实例：通过类的静态成员变量来体现。
   提供访问它的全局访问点：访问静态成员变量的静态成员函数来体现。
   单例类Singleton有以下特征：
   它有一个指向唯一实例的静态指针，并且是私有的；
   它有一个公有的函数，可以获取这个唯一的实例，并且在需要的时候创建该实例；
   它的构造函数是私有的，这样就不能从别处创建该类的实例。
** AbstractFactory
   要创建一组相关或者相互依赖的对象
   作用：提供一个创建一系列相关或相互依赖对象的接口，而无需指定它们具体的类。
** Factory工厂模式
   1、定义创建对象的接口，封装对象的创建
   2、将实际创建工作延迟到子类中，例如，类A中药使用类B,B是抽象父类，但是在类A中不知道具体要实例化哪一个B的子类，但是在类A的子类D中是可以知道的。在A中无法使用 new B***()方法
   3、将创建工作延迟到子类中后，核心工厂类不再负责产品的创建，这样核心类
   成为一个抽象工厂，只提供工厂子类必须实现的接口，这样的好处是可以不用修改已有的工厂类的情况下增加新的产品（每一种产品，都分别对应相应的工厂子类负责其创建工作）
   使用场景：用于一类类（所创建的产品继承共同的产品基类）的创建
   实现方式1：所谓的工厂方法模式，对每一个子类产品都分别对应一个工厂子类，用来创建相应的产品，这样若增加了新的产品，只需相应增加工厂子类即可
   优点：不用修改已有代码，开放封闭原则：对扩展开放，对更改封闭
   实现方式2：所谓的简单工厂模式，通过参数传递来决定要创建哪一个具体产品。
   若不需延迟实例化（将实例化放到子类中），则在Factory中增加对应的创建方法即可，如：Product* CreateConcreteProduct(int i);
   若需要延迟实例化，则在抽象Factory与具体ConcreteFactory中增加相应方法，在ConcreteFactory中实现方法Product* CreateConcreteProduct(int i)
   优点：无需新增产品工厂类ConcreteFactory
   缺点：需要修改已有代码，存在风险
** State状态模式
   作用：当一个对象的内在状态改变时允许改变其行为，这个对象看起来像是改变了其类
** Facade模式
   作用：为子系统中的一组接口提供一个一致的界面，Facade模式定义了一个高层接口，这个接口使得这一子系统更加容易使用。
   动机
   　　将一个系统划分成为若干个子系统有利于降低系统的复杂性。一个常见的设计目标是使子系统间的通信和相互依赖关系达到最小。
   达到该目标的途径之一是就是引入一个外观（Facade）对象，它为子系统中较一般的设施提供了一个单一而简单的界面。
   将各个子系统整合起来作为Facade，提供给客户端使用。
   适用性
   1.当你要为一个复杂子系统提供一个简单接口时。
   2.客户程序与抽象类的实现部分之间存在着很大的依赖性。
   3.当你需要构建一个层次结构的子系统时，使用Facade模式定义子系统中每层的入口点。仅通过facade进行通讯。
